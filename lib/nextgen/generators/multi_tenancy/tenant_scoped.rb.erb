# frozen_string_literal: true

# TenantScoped concern for automatic organization-based scoping
# This concern provides automatic tenant isolation for models that include it
module TenantScoped
  extend ActiveSupport::Concern

  # Configuration for bypass operations
  BYPASS_AUDIT_LOG_LEVEL = :warn
  BYPASS_ENABLED_ENVIRONMENTS = %w[development test production].freeze

  # Security error class for tenant scoping violations
  class TenantScopingError < SecurityError; end
  class AdminAuthorizationError < TenantScopingError; end
  class CrossTenantAccessError < TenantScopingError; end
  class UnscopedQueryError < TenantScopingError; end

  included do
    # Add belongs_to association to the organization
    belongs_to :<%= @organization_name.underscore %>, optional: false

    # Add validation to ensure organization is present
    validates :<%= @organization_name.underscore %>_id, presence: true

    # Apply default scope to filter by current organization
    default_scope -> {
      if TenantScoped.current_<%= @organization_name.underscore %>_id
        where(<%= @organization_name.underscore %>_id: TenantScoped.current_<%= @organization_name.underscore %>_id)
      else
        # If no organization is set, return empty relation in production to prevent data leakage
        # In development/test, we allow unscoped queries for easier testing
        if Rails.env.production?
          none
        else
          all
        end
      end
    }

    # Add index for performance on organization_id column
    # This should be added via migration when including this concern
    # add_index table_name, :<%= @organization_name.underscore %>_id

    # Ensure new records get the current organization
    before_validation :set_current_<%= @organization_name.underscore %>, on: :create

    # Add organization validation for updates as well
    before_update :ensure_<%= @organization_name.underscore %>_not_changed

    # Register this model for query monitoring
    after_initialize do
      TenantScoped.register_tenant_scoped_model(self.class)
    end
  end

  # Class methods for managing organization context and providing controlled bypass operations
  #
  # USAGE EXAMPLES:
  #
  # 1. Basic bypass for data migrations:
  #    MyModel.without_tenant_scoping { MyModel.update_all(status: 'migrated') }
  #
  # 2. Admin-authorized bypass:
  #    MyModel.with_admin_bypass(
  #      admin_check: -> { current_user&.admin? },
  #      reason: "Cross-tenant reporting"
  #    ) { MyModel.where(status: 'active') }
  #
  # 3. Cross-tenant admin operations:
  #    MyModel.with_organization_bypass(
  #      other_org_id,
  #      admin_check: -> { current_user&.super_admin? }
  #    ) { MyModel.create!(name: 'cross-tenant-record') }
  #
  # 4. Multi-tenant data migrations:
  #    MyModel.for_each_organization(
  #      admin_check: -> { current_user&.admin? }
  #    ) do |org|
  #      # Process each organization's data
  #      puts "Processing #{org.name}..."
  #    end
  #
  # 5. Read-only bypass for reports:
  #    MyModel.without_tenant_scoping_readonly { MyModel.joins(:other_model).count }
  #
  module ClassMethods
    # Temporarily bypass tenant scoping for admin operations
    # Use with extreme caution - mainly for data migrations and admin operations
    def without_tenant_scoping(&block)
      # Check if bypasses are globally disabled
      if TenantScoped.bypasses_disabled?
        raise TenantScoped::TenantScopingError, "Tenant scoping bypasses are globally disabled"
      end

      # Environment checks
      unless TenantScoped.bypass_enabled?
        raise TenantScoped::TenantScopingError, "Tenant scoping bypasses not enabled in #{Rails.env} environment"
      end

      # Production safeguards and logging
      if Rails.env.production?
        caller_location = caller(1..3)
        Rails.logger.warn("WARNING: Bypassing tenant scoping in production. Caller: #{caller_location}")

        # Optional: Check for admin authorization in production
        # Uncomment and implement if you have an admin authorization system
        # unless respond_to?(:current_user) && current_user&.admin?
        #   raise TenantScoped::AdminAuthorizationError, "Admin authorization required to bypass tenant scoping in production"
        # end
      end

      # Log all bypass operations for audit trail
      TenantScoped.log_bypass_operation(self.name, 'without_tenant_scoping', { caller: caller(1).first })

      # Set flag to prevent query monitoring false positives
      previous_bypass_flag = Thread.current[:tenant_scoping_bypass_active]
      Thread.current[:tenant_scoping_bypass_active] = true

      begin
        unscoped(&block)
      ensure
        Thread.current[:tenant_scoping_bypass_active] = previous_bypass_flag
      end
    end

    # Safely bypass scoping with explicit admin authorization check
    # Requires a block that returns true for authorized users
    def with_admin_bypass(admin_check: nil, reason: nil, &block)
      # Check if bypasses are globally disabled
      if TenantScoped.bypasses_disabled?
        raise TenantScoped::TenantScopingError, "Tenant scoping bypasses are globally disabled"
      end

      # Require explicit admin authorization in production
      if Rails.env.production? && admin_check
        unless admin_check.call
          raise TenantScoped::AdminAuthorizationError, "Admin authorization failed for tenant scoping bypass"
        end
      end

      # Log the bypass operation with reason
      TenantScoped.log_bypass_operation(self.name, 'with_admin_bypass', {
        reason: reason,
        admin_verified: admin_check ? 'Yes' : 'No'
      })

      # Set flag to prevent query monitoring false positives
      previous_bypass_flag = Thread.current[:tenant_scoping_bypass_active]
      Thread.current[:tenant_scoping_bypass_active] = true

      begin
        unscoped(&block)
      ensure
        Thread.current[:tenant_scoping_bypass_active] = previous_bypass_flag
      end
    end

    # Bypass scoping for specific organization (admin cross-tenant operations)
    def with_organization_bypass(<%= @organization_name.underscore %>_id, admin_check: nil, &block)
      # Check if bypasses are globally disabled
      if TenantScoped.bypasses_disabled?
        raise TenantScoped::TenantScopingError, "Tenant scoping bypasses are globally disabled"
      end

      # Validate organization exists
      <%= @organization_name.underscore %> = <%= @organization_name %>.find(<%= @organization_name.underscore %>_id)

      # Require admin authorization for cross-tenant access
      if Rails.env.production? && admin_check
        unless admin_check.call
          raise TenantScoped::CrossTenantAccessError, "Admin authorization required for cross-tenant access"
        end
      end

      # Log cross-tenant access
      TenantScoped.log_bypass_operation(self.name, 'with_organization_bypass', {
        target_organization: <%= @organization_name.underscore %>_id,
        admin_verified: admin_check ? 'Yes' : 'No'
      })

      # Temporarily switch organization context
      previous_<%= @organization_name.underscore %>_id = TenantScoped.current_<%= @organization_name.underscore %>_id
      TenantScoped.current_<%= @organization_name.underscore %>_id = <%= @organization_name.underscore %>_id

      begin
        yield
      ensure
        TenantScoped.current_<%= @organization_name.underscore %>_id = previous_<%= @organization_name.underscore %>_id
      end
    end

    # Safe method for data migrations that need to access all organizations
    def for_each_organization(admin_check: nil, &block)
      # Check if bypasses are globally disabled
      if TenantScoped.bypasses_disabled?
        raise TenantScoped::TenantScopingError, "Tenant scoping bypasses are globally disabled"
      end

      # Require admin authorization for multi-tenant operations
      if Rails.env.production? && admin_check
        unless admin_check.call
          raise TenantScoped::AdminAuthorizationError, "Admin authorization required for multi-tenant operations"
        end
      end

      TenantScoped.log_bypass_operation(self.name, 'for_each_organization', {
        admin_verified: admin_check ? 'Yes' : 'No'
      })

      # Clear current organization context and iterate through all organizations
      previous_<%= @organization_name.underscore %>_id = TenantScoped.current_<%= @organization_name.underscore %>_id

      begin
        <%= @organization_name %>.find_each do |<%= @organization_name.underscore %>|
          TenantScoped.current_<%= @organization_name.underscore %>_id = <%= @organization_name.underscore %>.id
          Rails.logger.debug("[MULTI_TENANT] Processing organization: #{<%= @organization_name.underscore %>.id}")

          yield(<%= @organization_name.underscore %>)
        end
      ensure
        TenantScoped.current_<%= @organization_name.underscore %>_id = previous_<%= @organization_name.underscore %>_id
      end
    end

    # Scope to a specific organization (explicitly unscoped first)
    def for_<%= @organization_name.underscore %>(<%= @organization_name.underscore %>)
      unscoped.where(<%= @organization_name.underscore %>_id: <%= @organization_name.underscore %>.id)
    end

    # Bypass scoping for read-only operations (safer for reporting)
    def without_tenant_scoping_readonly(&block)
      # Check if bypasses are globally disabled
      if TenantScoped.bypasses_disabled?
        raise TenantScoped::TenantScopingError, "Tenant scoping bypasses are globally disabled"
      end

      TenantScoped.log_bypass_operation(self.name, 'without_tenant_scoping_readonly')

      # Set flag to prevent query monitoring false positives
      previous_bypass_flag = Thread.current[:tenant_scoping_bypass_active]
      Thread.current[:tenant_scoping_bypass_active] = true

      begin
        # Return read-only relation to prevent accidental modifications
        unscoped do
          relation = yield
          relation.respond_to?(:readonly) ? relation.readonly : relation
        end
      ensure
        Thread.current[:tenant_scoping_bypass_active] = previous_bypass_flag
      end
    end

    # Check if tenant scoping is currently active
    def tenant_scoping_active?
      TenantScoped.current_<%= @organization_name.underscore %>_id.present?
    end

    # Get current organization for this model
    def current_<%= @organization_name.underscore %>
      return nil unless TenantScoped.current_<%= @organization_name.underscore %>_id

      @current_<%= @organization_name.underscore %> ||= <%= @organization_name %>.find(TenantScoped.current_<%= @organization_name.underscore %>_id)
    end
  end

  # Thread-safe storage for current organization context
  # This ensures tenant isolation across concurrent requests
  def self.current_<%= @organization_name.underscore %>_id
    if defined?(RequestStore)
      RequestStore.store[:current_<%= @organization_name.underscore %>_id] ||
        Thread.current[:current_<%= @organization_name.underscore %>_id]
    else
      Thread.current[:current_<%= @organization_name.underscore %>_id]
    end
  end

  def self.current_<%= @organization_name.underscore %>_id=(id)
    RequestStore.store[:current_<%= @organization_name.underscore %>_id] = id if defined?(RequestStore)
    Thread.current[:current_<%= @organization_name.underscore %>_id] = id
  end

  # Check if tenant scoping context is properly configured
  def self.context_storage_available?
    defined?(RequestStore) || Thread.current.respond_to?(:[])
  end

  # Clear all organization context (use with extreme caution)
  def self.clear_context!
    if Rails.env.production?
      Rails.logger.warn("WARNING: Clearing tenant context in production. Caller: #{caller(1..3)}")
    end

    RequestStore.store[:current_<%= @organization_name.underscore %>_id] = nil if defined?(RequestStore)
    Thread.current[:current_<%= @organization_name.underscore %>_id] = nil
    @current_<%= @organization_name.underscore %> = nil
  end

  def self.current_<%= @organization_name.underscore %>
    return nil unless current_<%= @organization_name.underscore %>_id

    @current_<%= @organization_name.underscore %> ||= <%= @organization_name %>.unscoped.find(current_<%= @organization_name.underscore %>_id)
  end

  def self.current_<%= @organization_name.underscore %>=(<%= @organization_name.underscore %>)
    self.current_<%= @organization_name.underscore %>_id = <%= @organization_name.underscore %>&.id
    @current_<%= @organization_name.underscore %> = <%= @organization_name.underscore %>
  end

  # Set organization context for the duration of a block
  def self.with_<%= @organization_name.underscore %>(<%= @organization_name.underscore %>)
    previous_<%= @organization_name.underscore %>_id = current_<%= @organization_name.underscore %>_id
    previous_<%= @organization_name.underscore %> = @current_<%= @organization_name.underscore %>

    self.current_<%= @organization_name.underscore %> = <%= @organization_name.underscore %>

    yield
  ensure
    self.current_<%= @organization_name.underscore %>_id = previous_<%= @organization_name.underscore %>_id
    @current_<%= @organization_name.underscore %> = previous_<%= @organization_name.underscore %>
  end

  # Clear organization context (use with caution)
  def self.without_<%= @organization_name.underscore %>
    previous_<%= @organization_name.underscore %>_id = current_<%= @organization_name.underscore %>_id
    previous_<%= @organization_name.underscore %> = @current_<%= @organization_name.underscore %>

    self.current_<%= @organization_name.underscore %>_id = nil
    @current_<%= @organization_name.underscore %> = nil

    yield
  ensure
    self.current_<%= @organization_name.underscore %>_id = previous_<%= @organization_name.underscore %>_id
    @current_<%= @organization_name.underscore %> = previous_<%= @organization_name.underscore %>
  end

  # Instance methods
  def belongs_to_current_<%= @organization_name.underscore %>?
    <%= @organization_name.underscore %>_id == TenantScoped.current_<%= @organization_name.underscore %>_id
  end

  def can_be_accessed_by?(<%= @organization_name.underscore %>)
    self.<%= @organization_name.underscore %>_id == <%= @organization_name.underscore %>.id
  end

  private

  def set_current_<%= @organization_name.underscore %>
    return if <%= @organization_name.underscore %>_id.present?
    return unless TenantScoped.current_<%= @organization_name.underscore %>_id

    self.<%= @organization_name.underscore %>_id = TenantScoped.current_<%= @organization_name.underscore %>_id
  end

  def ensure_<%= @organization_name.underscore %>_not_changed
    return unless <%= @organization_name.underscore %>_id_changed?

    errors.add(:<%= @organization_name.underscore %>_id, "cannot be changed after creation")
    throw :abort
  end

  # Module methods for bypass control and monitoring
  module_function

  # Check if bypass operations are enabled in current environment
  def bypass_enabled?
    BYPASS_ENABLED_ENVIRONMENTS.include?(Rails.env)
  end

  # Global flag to temporarily disable all bypass operations (emergency stop)
  def disable_all_bypasses!
    @bypasses_disabled = true
    Rails.logger.error("[EMERGENCY] All tenant scoping bypasses have been globally disabled")
  end

  def enable_bypasses!
    @bypasses_disabled = false
    Rails.logger.warn("[SECURITY] Tenant scoping bypasses have been re-enabled")
  end

  def bypasses_disabled?
    @bypasses_disabled || false
  end

  # Audit trail helpers
  def log_bypass_operation(model_name, operation_type, details = {})
    log_data = {
      model: model_name,
      operation: operation_type,
      timestamp: Time.current,
      environment: Rails.env,
      caller: caller(2..4),
      **details
    }

    Rails.logger.public_send(BYPASS_AUDIT_LOG_LEVEL, "[TENANT_AUDIT] #{log_data.to_json}")
  end

  # Query monitoring for unscoped query detection in production
  # This system monitors SQL queries to detect and prevent unscoped queries that could lead to data leakage

  # Initialize query monitoring (call this in an initializer)
  def self.setup_query_monitoring!
    return unless Rails.env.production?
    return if @query_monitoring_setup

    # Track models that should have tenant scoping
    @tenant_scoped_models = Set.new

    # Monitor SQL queries for unscoped operations
    ActiveSupport::Notifications.subscribe("sql.active_record") do |event|
      next unless should_monitor_query?(event)

      sql = event.payload[:sql]
      name = event.payload[:name]
      connection = event.payload[:connection]

      detect_unscoped_query(sql, name, connection, event)
    end

    @query_monitoring_setup = true
    Rails.logger.info("[TENANT_MONITOR] Query monitoring for tenant scoping enabled")
  end

  # Register a model as requiring tenant scoping
  def self.register_tenant_scoped_model(model_class)
    @tenant_scoped_models ||= Set.new
    @tenant_scoped_models.add(model_class.table_name)
    Rails.logger.debug("[TENANT_MONITOR] Registered #{model_class.name} for tenant scoping monitoring")
  end

  # Check if we should monitor this query
  def self.should_monitor_query?(event)
    # Skip non-production environments unless explicitly enabled
    return false unless Rails.env.production? || ENV['TENANT_SCOPING_MONITOR'] == 'true'

    # Skip certain query types that don't need monitoring
    name = event.payload[:name]
    sql = event.payload[:sql]

    # Skip schema queries, migrations, and Rails internal queries
    return false if name&.match?(/SCHEMA|Migration|ActiveRecord::|Rails::/)
    return false if sql&.match?(/information_schema|pg_|sqlite_|PRAGMA|SHOW/)

    # Skip queries during bypasses (thread-local flag)
    return false if Thread.current[:tenant_scoping_bypass_active]

    true
  end

  # Detect potentially unscoped queries
  def self.detect_unscoped_query(sql, name, connection, event)
    return unless @tenant_scoped_models&.any?

    # Check if this query touches tenant-scoped tables without proper filtering
    @tenant_scoped_models.each do |table_name|
      next unless sql.match?(/FROM\s+["`]?#{table_name}["`]?|JOIN\s+["`]?#{table_name}["`]?/i)

      # Look for organization_id filtering in the WHERE clause
      unless has_organization_filter?(sql, table_name)
        handle_unscoped_query_violation(sql, name, table_name, event)
      end
    end
  end

  # Check if SQL has proper organization filtering
  def self.has_organization_filter?(sql, table_name)
    # Look for organization_id in WHERE clause (various formats)
    patterns = [
      /WHERE.*#{table_name}["`]?\.["`]?<%= @organization_name.underscore %>_id\s*[=]/i,
      /WHERE.*["`]?<%= @organization_name.underscore %>_id["`]?\s*[=]/i,
      /AND.*#{table_name}["`]?\.["`]?<%= @organization_name.underscore %>_id\s*[=]/i,
      /AND.*["`]?<%= @organization_name.underscore %>_id["`]?\s*[=]/i
    ]

    patterns.any? { |pattern| sql.match?(pattern) }
  end

  # Handle unscoped query violations
  def self.handle_unscoped_query_violation(sql, name, table_name, event)
    caller_info = caller(6..10)&.join("\n") || "Unknown caller"

    violation_data = {
      sql: sql,
      query_name: name,
      table: table_name,
      timestamp: Time.current,
      environment: Rails.env,
      caller: caller_info,
      current_org_id: current_<%= @organization_name.underscore %>_id,
      connection_id: event.payload[:connection]&.object_id
    }

    # Log the violation
    Rails.logger.error("[TENANT_VIOLATION] Unscoped query detected: #{violation_data.to_json}")

    # In production, this could be configured to:
    # 1. Just log (current behavior)
    # 2. Send alerts to monitoring systems
    # 3. Raise an exception (strict mode)

    if ENV['TENANT_SCOPING_STRICT'] == 'true'
      raise UnscopedQueryError, "Unscoped query detected on table '#{table_name}': #{sql.truncate(200)}"
    end

    # Optional: Send to external monitoring (uncomment and configure as needed)
    # send_unscoped_query_alert(violation_data)
  end

  # Send alerts to external monitoring systems (implement as needed)
  # def self.send_unscoped_query_alert(violation_data)
  #   # Example: Send to error tracking service
  #   # Bugsnag.notify(UnscopedQueryError.new("Unscoped query detected"), violation_data)
  #   #
  #   # Example: Send to metrics service
  #   # StatsD.increment("tenant_scoping.unscoped_query", tags: { table: violation_data[:table] })
  # end

  # Enable/disable query monitoring
  def self.enable_query_monitoring!
    @query_monitoring_disabled = false
    Rails.logger.info("[TENANT_MONITOR] Query monitoring enabled")
  end

  def self.disable_query_monitoring!
    @query_monitoring_disabled = true
    Rails.logger.warn("[TENANT_MONITOR] Query monitoring disabled")
  end

  def self.query_monitoring_disabled?
    @query_monitoring_disabled || false
  end
end

# ApplicationController helper methods for setting organization context
# Include this in your ApplicationController or a parent controller
#
# NOTE: For optimal thread safety in production, add the 'request_store' gem to your Gemfile:
#   gem 'request_store'
# The concern will work without it using Thread.current, but RequestStore provides
# better request isolation in multi-threaded environments.
module TenantScoped::ControllerHelpers
  extend ActiveSupport::Concern

  included do
    # Automatically set organization context from current user
    before_action :set_current_<%= @organization_name.underscore %>

    # Helper method available in views
    helper_method :current_<%= @organization_name.underscore %>

    private

    def set_current_<%= @organization_name.underscore %>
      return unless user_signed_in? # Adjust based on your authentication method
      return unless respond_to?(:current_user) && current_user

      # Clear any previous context to prevent cross-request contamination
      TenantScoped.current_<%= @organization_name.underscore %>_id = nil

      # If user has only one organization, use it automatically
      user_<%= @organization_name.underscore.pluralize %> = current_user.<%= @organization_name.underscore.pluralize %>

      if user_<%= @organization_name.underscore.pluralize %>.count == 1
        TenantScoped.current_<%= @organization_name.underscore %> = user_<%= @organization_name.underscore.pluralize %>.first
      elsif params[:<%= @organization_name.underscore %>_id].present?
        # Use organization from params if provided and user has access
        <%= @organization_name.underscore %> = user_<%= @organization_name.underscore.pluralize %>.find_by(id: params[:<%= @organization_name.underscore %>_id])
        if <%= @organization_name.underscore %>
          TenantScoped.current_<%= @organization_name.underscore %> = <%= @organization_name.underscore %>
        else
          Rails.logger.warn("User #{current_user.id} attempted to access unauthorized organization #{params[:<%= @organization_name.underscore %>_id]}")
        end
      elsif session[:current_<%= @organization_name.underscore %>_id].present?
        # Use organization from session if user has access
        <%= @organization_name.underscore %> = user_<%= @organization_name.underscore.pluralize %>.find_by(id: session[:current_<%= @organization_name.underscore %>_id])
        TenantScoped.current_<%= @organization_name.underscore %> = <%= @organization_name.underscore %> if <%= @organization_name.underscore %>
      end

      # Store in session for future requests
      session[:current_<%= @organization_name.underscore %>_id] = TenantScoped.current_<%= @organization_name.underscore %>_id

      # Log context switches for debugging
      if Rails.env.development? && TenantScoped.current_<%= @organization_name.underscore %>_id
        Rails.logger.debug("Set tenant context to organization #{TenantScoped.current_<%= @organization_name.underscore %>_id}")
      end
    rescue => e
      Rails.logger.error("Failed to set organization context: #{e.message}")
      # Clear context on error to prevent data leakage
      TenantScoped.current_<%= @organization_name.underscore %>_id = nil
      raise if Rails.env.development?
    end

    def current_<%= @organization_name.underscore %>
      TenantScoped.current_<%= @organization_name.underscore %>
    end

    def require_<%= @organization_name.underscore %>
      unless TenantScoped.current_<%= @organization_name.underscore %>
        redirect_to <%= @organization_name.underscore.pluralize %>_path, alert: "Please select an <%= @organization_name.underscore %> to continue."
      end
    end

    # Switch organization context (useful for organization selection)
    def switch_<%= @organization_name.underscore %>(<%= @organization_name.underscore %>)
      return unless current_user.<%= @organization_name.underscore.pluralize %>.include?(<%= @organization_name.underscore %>)

      TenantScoped.current_<%= @organization_name.underscore %> = <%= @organization_name.underscore %>
      session[:current_<%= @organization_name.underscore %>_id] = <%= @organization_name.underscore %>.id
    end

    # Explicit organization setter with authorization checking
    # Use this for programmatic organization switching (e.g., organization selection form)
    def set_<%= @organization_name.underscore %>_context!(<%= @organization_name.underscore %>_id_or_object, authorized_user: nil)
      user = authorized_user || current_user
      raise TenantScoped::TenantScopingError, "No user provided for organization context setting" unless user

      <%= @organization_name.underscore %> = <%= @organization_name.underscore %>_id_or_object.is_a?(<%= @organization_name %>) ?
        <%= @organization_name.underscore %>_id_or_object :
        user.<%= @organization_name.underscore.pluralize %>.find(<%= @organization_name.underscore %>_id_or_object)

      # Verify user has access to this organization
      unless user.<%= @organization_name.underscore.pluralize %>.include?(<%= @organization_name.underscore %>)
        raise TenantScoped::CrossTenantAccessError,
          "User #{user.id} does not have access to organization #{<%= @organization_name.underscore %>.id}"
      end

      TenantScoped.current_<%= @organization_name.underscore %> = <%= @organization_name.underscore %>
      session[:current_<%= @organization_name.underscore %>_id] = <%= @organization_name.underscore %>.id if respond_to?(:session)

      Rails.logger.info("Organization context set to #{<%= @organization_name.underscore %>.id} for user #{user.id}")
      <%= @organization_name.underscore %>
    end

    # Clear organization context (useful for logout or context reset)
    def clear_<%= @organization_name.underscore %>_context!
      TenantScoped.current_<%= @organization_name.underscore %>_id = nil
      session[:current_<%= @organization_name.underscore %>_id] = nil if respond_to?(:session)
      Rails.logger.debug("Organization context cleared")
    end

    # Temporarily execute a block with a different organization context
    # Useful for cross-tenant operations that the current user is authorized for
    def with_<%= @organization_name.underscore %>_context(<%= @organization_name.underscore %>_id_or_object, authorized_user: nil, &block)
      user = authorized_user || current_user
      raise TenantScoped::TenantScopingError, "No user provided for temporary organization context" unless user

      <%= @organization_name.underscore %> = <%= @organization_name.underscore %>_id_or_object.is_a?(<%= @organization_name %>) ?
        <%= @organization_name.underscore %>_id_or_object :
        user.<%= @organization_name.underscore.pluralize %>.find(<%= @organization_name.underscore %>_id_or_object)

      # Verify user has access to this organization
      unless user.<%= @organization_name.underscore.pluralize %>.include?(<%= @organization_name.underscore %>)
        raise TenantScoped::CrossTenantAccessError,
          "User #{user.id} does not have access to organization #{<%= @organization_name.underscore %>.id}"
      end

      TenantScoped.with_<%= @organization_name.underscore %>(<%= @organization_name.underscore %>, &block)
    end

    # Validate current organization context
    def validate_<%= @organization_name.underscore %>_context!(user: nil)
      user ||= current_user
      current_<%= @organization_name.underscore %>_obj = TenantScoped.current_<%= @organization_name.underscore %>

      unless current_<%= @organization_name.underscore %>_obj
        raise TenantScoped::TenantScopingError, "No organization context set"
      end

      if user && !user.<%= @organization_name.underscore.pluralize %>.include?(current_<%= @organization_name.underscore %>_obj)
        raise TenantScoped::CrossTenantAccessError,
          "User #{user.id} does not have access to current organization #{current_<%= @organization_name.underscore %>_obj.id}"
      end

      current_<%= @organization_name.underscore %>_obj
    end
  end
end

# Service and background job helper methods for organization context
# Include this in your service objects and background jobs
#
# USAGE EXAMPLES:
#
# class ReportGenerationService
#   include TenantScoped::ServiceHelpers
#
#   def initialize(user:)
#     @user = user
#     ensure_organization_context!(@user)
#   end
#
#   def generate_report
#     # All queries here will be automatically scoped to the current organization
#     User.count # Only counts users in current organization
#   end
# end
#
# class BackgroundReportJob < ApplicationJob
#   include TenantScoped::ServiceHelpers
#
#   def perform(user_id, organization_id)
#     user = User.unscoped.find(user_id)
#     execute_with_organization_context(organization_id, authorized_user: user) do
#       # Job logic here - all queries scoped to organization
#       generate_and_email_report
#     end
#   end
# end
module TenantScoped::ServiceHelpers
  extend ActiveSupport::Concern

  # Set organization context for service operations
  # Call this at the beginning of service methods that need tenant scoping
  def set_service_<%= @organization_name.underscore %>_context!(<%= @organization_name.underscore %>_id_or_object, authorized_user:)
    raise TenantScoped::TenantScopingError, "No user provided for service organization context" unless authorized_user

    <%= @organization_name.underscore %> = <%= @organization_name.underscore %>_id_or_object.is_a?(<%= @organization_name %>) ?
      <%= @organization_name.underscore %>_id_or_object :
      authorized_user.<%= @organization_name.underscore.pluralize %>.find(<%= @organization_name.underscore %>_id_or_object)

    # Verify user has access to this organization
    unless authorized_user.<%= @organization_name.underscore.pluralize %>.include?(<%= @organization_name.underscore %>)
      raise TenantScoped::CrossTenantAccessError,
        "User #{authorized_user.id} does not have access to organization #{<%= @organization_name.underscore %>.id}"
    end

    TenantScoped.current_<%= @organization_name.underscore %> = <%= @organization_name.underscore %>
    Rails.logger.info("Service organization context set to #{<%= @organization_name.underscore %>.id} for user #{authorized_user.id}")
    <%= @organization_name.underscore %>
  end

  # Ensure organization context is set, raise error if not
  # Use this for services that require organization context
  def ensure_<%= @organization_name.underscore %>_context!(user: nil)
    current_<%= @organization_name.underscore %>_obj = TenantScoped.current_<%= @organization_name.underscore %>

    unless current_<%= @organization_name.underscore %>_obj
      raise TenantScoped::TenantScopingError, "Organization context required but not set"
    end

    if user && !user.<%= @organization_name.underscore.pluralize %>.include?(current_<%= @organization_name.underscore %>_obj)
      raise TenantScoped::CrossTenantAccessError,
        "User #{user.id} does not have access to current organization #{current_<%= @organization_name.underscore %>_obj.id}"
    end

    current_<%= @organization_name.underscore %>_obj
  end

  # Execute a block with organization context set
  # Useful for background jobs and service methods
  def execute_with_<%= @organization_name.underscore %>_context(<%= @organization_name.underscore %>_id_or_object, authorized_user:, &block)
    raise TenantScoped::TenantScopingError, "No block provided" unless block_given?

    <%= @organization_name.underscore %> = <%= @organization_name.underscore %>_id_or_object.is_a?(<%= @organization_name %>) ?
      <%= @organization_name.underscore %>_id_or_object :
      authorized_user.<%= @organization_name.underscore.pluralize %>.find(<%= @organization_name.underscore %>_id_or_object)

    # Verify user has access to this organization
    unless authorized_user.<%= @organization_name.underscore.pluralize %>.include?(<%= @organization_name.underscore %>)
      raise TenantScoped::CrossTenantAccessError,
        "User #{authorized_user.id} does not have access to organization #{<%= @organization_name.underscore %>.id}"
    end

    TenantScoped.with_<%= @organization_name.underscore %>(<%= @organization_name.underscore %>, &block)
  end

  # Clear organization context (useful for cleanup)
  def clear_service_<%= @organization_name.underscore %>_context!
    TenantScoped.current_<%= @organization_name.underscore %>_id = nil
    Rails.logger.debug("Service organization context cleared")
  end

  # Get current organization for service operations
  def current_service_<%= @organization_name.underscore %>
    TenantScoped.current_<%= @organization_name.underscore %>
  end

  # Switch organization context for cross-tenant service operations
  # Use with extreme caution - ensure proper authorization
  def switch_service_<%= @organization_name.underscore %>_context!(<%= @organization_name.underscore %>_id_or_object, authorized_user:, admin_check: nil)
    # Extra authorization check for cross-tenant operations
    if admin_check && !admin_check.call
      raise TenantScoped::AdminAuthorizationError, "Admin authorization required for cross-tenant service operation"
    end

    set_service_<%= @organization_name.underscore %>_context!(<%= @organization_name.underscore %>_id_or_object, authorized_user: authorized_user)
  end
end

# SETUP INSTRUCTIONS FOR QUERY MONITORING
#
# Add this to your Rails application initializer (config/initializers/tenant_scoping.rb):
#
#   if Rails.env.production?
#     TenantScoped.setup_query_monitoring!
#   end
#
# ENVIRONMENT VARIABLES:
#
# TENANT_SCOPING_MONITOR=true    - Enable monitoring in non-production environments
# TENANT_SCOPING_STRICT=true     - Raise exceptions instead of just logging violations
#
# PRODUCTION DEPLOYMENT CHECKLIST:
#
# 1. Set up query monitoring in initializer
# 2. Configure error tracking (Bugsnag, Sentry, etc.) to capture UnscopedQueryError
# 3. Set up metrics/alerting for tenant scoping violations
# 4. Monitor logs for [TENANT_VIOLATION] entries
# 5. Consider enabling TENANT_SCOPING_STRICT after thorough testing
#
# EXAMPLE USAGE:
#
# # Safe bypass for admin operations
# User.with_admin_bypass(
#   admin_check: -> { current_user&.admin? },
#   reason: "Generating cross-tenant report"
# ) do
#   User.joins(:memberships).group(:organization_id).count
# end
#
# # Data migration example
# User.without_tenant_scoping do
#   User.where(organization_id: nil).update_all(organization_id: default_org.id)
# end
#
# # Multi-tenant operations
# User.for_each_organization(admin_check: -> { current_user&.super_admin? }) do |org|
#   # Process each organization's data safely
#   puts "Processing #{org.name}: #{User.count} users"
# end
#
# CONTROLLER USAGE EXAMPLES:
#
# # In ApplicationController:
# class ApplicationController < ActionController::Base
#   include TenantScoped::ControllerHelpers
#   # Automatic organization context setting via before_action
# end
#
# # Manual organization context setting:
# def switch_organization
#   org = set_organization_context!(params[:organization_id])
#   redirect_to dashboard_path, notice: "Switched to #{org.name}"
# rescue TenantScoped::CrossTenantAccessError => e
#   redirect_to organizations_path, alert: e.message
# end
#
# # Temporary cross-tenant operations:
# def admin_report
#   with_organization_context(params[:target_org_id]) do
#     @users = User.all # Scoped to target organization
#     @projects = Project.all # Also scoped to target organization
#   end
# end
#
# # Context validation:
# before_action :validate_organization_context!
#
# SERVICE USAGE EXAMPLES:
#
# # Service object with organization context:
# class ReportGenerationService
#   include TenantScoped::ServiceHelpers
#
#   def initialize(user:, organization_id: nil)
#     @user = user
#     if organization_id
#       set_service_organization_context!(organization_id, authorized_user: @user)
#     else
#       ensure_organization_context!(user: @user)
#     end
#   end
#
#   def generate_report
#     # All queries automatically scoped to current organization
#     {
#       users_count: User.count,
#       projects_count: Project.count,
#       organization: current_service_organization.name
#     }
#   end
# end
#
# # Background job with organization context:
# class WeeklyReportJob < ApplicationJob
#   include TenantScoped::ServiceHelpers
#
#   def perform(user_id, organization_id)
#     user = User.unscoped.find(user_id)
#     execute_with_organization_context(organization_id, authorized_user: user) do
#       # All database operations here are scoped to the organization
#       report_data = generate_weekly_report
#       ReportMailer.weekly_report(user, report_data).deliver_now
#     end
#   rescue TenantScoped::CrossTenantAccessError => e
#     Rails.logger.error("Job authorization failed: #{e.message}")
#     raise
#   end
# end
#
# # Cross-tenant admin service:
# class CrossTenantAuditService
#   include TenantScoped::ServiceHelpers
#
#   def perform_audit(admin_user:, target_organization_ids:)
#     ensure_admin_authorized!(admin_user)
#
#     target_organization_ids.each do |org_id|
#       switch_service_organization_context!(
#         org_id,
#         authorized_user: admin_user,
#         admin_check: -> { admin_user.super_admin? }
#       )
#
#       audit_organization_data
#     end
#   ensure
#     clear_service_organization_context!
#   end
# end
