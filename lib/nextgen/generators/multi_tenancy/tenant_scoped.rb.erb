# frozen_string_literal: true

# TenantScoped concern for automatic organization-based scoping
# This concern provides automatic tenant isolation for models that include it
module TenantScoped
  extend ActiveSupport::Concern

  # Configuration for bypass operations
  BYPASS_AUDIT_LOG_LEVEL = :warn
  BYPASS_ENABLED_ENVIRONMENTS = %w[development test production].freeze

  # Security error class for tenant scoping violations
  class TenantScopingError < SecurityError; end
  class AdminAuthorizationError < TenantScopingError; end
  class CrossTenantAccessError < TenantScopingError; end

  included do
    # Add belongs_to association to the organization
    belongs_to :<%= @organization_name.underscore %>, optional: false

    # Add validation to ensure organization is present
    validates :<%= @organization_name.underscore %>_id, presence: true

    # Apply default scope to filter by current organization
    default_scope -> {
      if TenantScoped.current_<%= @organization_name.underscore %>_id
        where(<%= @organization_name.underscore %>_id: TenantScoped.current_<%= @organization_name.underscore %>_id)
      else
        # If no organization is set, return empty relation in production to prevent data leakage
        # In development/test, we allow unscoped queries for easier testing
        if Rails.env.production?
          none
        else
          all
        end
      end
    }

    # Add index for performance on organization_id column
    # This should be added via migration when including this concern
    # add_index table_name, :<%= @organization_name.underscore %>_id

    # Ensure new records get the current organization
    before_validation :set_current_<%= @organization_name.underscore %>, on: :create

    # Add organization validation for updates as well
    before_update :ensure_<%= @organization_name.underscore %>_not_changed
  end

  # Class methods for managing organization context and providing controlled bypass operations
  #
  # USAGE EXAMPLES:
  #
  # 1. Basic bypass for data migrations:
  #    MyModel.without_tenant_scoping { MyModel.update_all(status: 'migrated') }
  #
  # 2. Admin-authorized bypass:
  #    MyModel.with_admin_bypass(
  #      admin_check: -> { current_user&.admin? },
  #      reason: "Cross-tenant reporting"
  #    ) { MyModel.where(status: 'active') }
  #
  # 3. Cross-tenant admin operations:
  #    MyModel.with_organization_bypass(
  #      other_org_id,
  #      admin_check: -> { current_user&.super_admin? }
  #    ) { MyModel.create!(name: 'cross-tenant-record') }
  #
  # 4. Multi-tenant data migrations:
  #    MyModel.for_each_organization(
  #      admin_check: -> { current_user&.admin? }
  #    ) do |org|
  #      # Process each organization's data
  #      puts "Processing #{org.name}..."
  #    end
  #
  # 5. Read-only bypass for reports:
  #    MyModel.without_tenant_scoping_readonly { MyModel.joins(:other_model).count }
  #
  module ClassMethods
    # Temporarily bypass tenant scoping for admin operations
    # Use with extreme caution - mainly for data migrations and admin operations
    def without_tenant_scoping(&block)
      # Check if bypasses are globally disabled
      if TenantScoped.bypasses_disabled?
        raise TenantScoped::TenantScopingError, "Tenant scoping bypasses are globally disabled"
      end

      # Environment checks
      unless TenantScoped.bypass_enabled?
        raise TenantScoped::TenantScopingError, "Tenant scoping bypasses not enabled in #{Rails.env} environment"
      end

      # Production safeguards and logging
      if Rails.env.production?
        caller_location = caller(1..3)
        Rails.logger.warn("WARNING: Bypassing tenant scoping in production. Caller: #{caller_location}")

        # Optional: Check for admin authorization in production
        # Uncomment and implement if you have an admin authorization system
        # unless respond_to?(:current_user) && current_user&.admin?
        #   raise TenantScoped::AdminAuthorizationError, "Admin authorization required to bypass tenant scoping in production"
        # end
      end

      # Log all bypass operations for audit trail
      TenantScoped.log_bypass_operation(self.name, 'without_tenant_scoping', { caller: caller(1).first })

      unscoped(&block)
    end

    # Safely bypass scoping with explicit admin authorization check
    # Requires a block that returns true for authorized users
    def with_admin_bypass(admin_check: nil, reason: nil, &block)
      # Check if bypasses are globally disabled
      if TenantScoped.bypasses_disabled?
        raise TenantScoped::TenantScopingError, "Tenant scoping bypasses are globally disabled"
      end

      # Require explicit admin authorization in production
      if Rails.env.production? && admin_check
        unless admin_check.call
          raise TenantScoped::AdminAuthorizationError, "Admin authorization failed for tenant scoping bypass"
        end
      end

      # Log the bypass operation with reason
      TenantScoped.log_bypass_operation(self.name, 'with_admin_bypass', {
        reason: reason,
        admin_verified: admin_check ? 'Yes' : 'No'
      })

      unscoped(&block)
    end

    # Bypass scoping for specific organization (admin cross-tenant operations)
    def with_organization_bypass(<%= @organization_name.underscore %>_id, admin_check: nil, &block)
      # Check if bypasses are globally disabled
      if TenantScoped.bypasses_disabled?
        raise TenantScoped::TenantScopingError, "Tenant scoping bypasses are globally disabled"
      end

      # Validate organization exists
      <%= @organization_name.underscore %> = <%= @organization_name %>.find(<%= @organization_name.underscore %>_id)

      # Require admin authorization for cross-tenant access
      if Rails.env.production? && admin_check
        unless admin_check.call
          raise TenantScoped::CrossTenantAccessError, "Admin authorization required for cross-tenant access"
        end
      end

      # Log cross-tenant access
      TenantScoped.log_bypass_operation(self.name, 'with_organization_bypass', {
        target_organization: <%= @organization_name.underscore %>_id,
        admin_verified: admin_check ? 'Yes' : 'No'
      })

      # Temporarily switch organization context
      previous_<%= @organization_name.underscore %>_id = TenantScoped.current_<%= @organization_name.underscore %>_id
      TenantScoped.current_<%= @organization_name.underscore %>_id = <%= @organization_name.underscore %>_id

      begin
        yield
      ensure
        TenantScoped.current_<%= @organization_name.underscore %>_id = previous_<%= @organization_name.underscore %>_id
      end
    end

    # Safe method for data migrations that need to access all organizations
    def for_each_organization(admin_check: nil, &block)
      # Check if bypasses are globally disabled
      if TenantScoped.bypasses_disabled?
        raise TenantScoped::TenantScopingError, "Tenant scoping bypasses are globally disabled"
      end

      # Require admin authorization for multi-tenant operations
      if Rails.env.production? && admin_check
        unless admin_check.call
          raise TenantScoped::AdminAuthorizationError, "Admin authorization required for multi-tenant operations"
        end
      end

      TenantScoped.log_bypass_operation(self.name, 'for_each_organization', {
        admin_verified: admin_check ? 'Yes' : 'No'
      })

      # Clear current organization context and iterate through all organizations
      previous_<%= @organization_name.underscore %>_id = TenantScoped.current_<%= @organization_name.underscore %>_id

      begin
        <%= @organization_name %>.find_each do |<%= @organization_name.underscore %>|
          TenantScoped.current_<%= @organization_name.underscore %>_id = <%= @organization_name.underscore %>.id
          Rails.logger.debug("[MULTI_TENANT] Processing organization: #{<%= @organization_name.underscore %>.id}")

          yield(<%= @organization_name.underscore %>)
        end
      ensure
        TenantScoped.current_<%= @organization_name.underscore %>_id = previous_<%= @organization_name.underscore %>_id
      end
    end

    # Scope to a specific organization (explicitly unscoped first)
    def for_<%= @organization_name.underscore %>(<%= @organization_name.underscore %>)
      unscoped.where(<%= @organization_name.underscore %>_id: <%= @organization_name.underscore %>.id)
    end

    # Bypass scoping for read-only operations (safer for reporting)
    def without_tenant_scoping_readonly(&block)
      # Check if bypasses are globally disabled
      if TenantScoped.bypasses_disabled?
        raise TenantScoped::TenantScopingError, "Tenant scoping bypasses are globally disabled"
      end

      TenantScoped.log_bypass_operation(self.name, 'without_tenant_scoping_readonly')

      # Return read-only relation to prevent accidental modifications
      unscoped do
        relation = yield
        relation.respond_to?(:readonly) ? relation.readonly : relation
      end
    end

    # Check if tenant scoping is currently active
    def tenant_scoping_active?
      TenantScoped.current_<%= @organization_name.underscore %>_id.present?
    end

    # Get current organization for this model
    def current_<%= @organization_name.underscore %>
      return nil unless TenantScoped.current_<%= @organization_name.underscore %>_id

      @current_<%= @organization_name.underscore %> ||= <%= @organization_name %>.find(TenantScoped.current_<%= @organization_name.underscore %>_id)
    end
  end

  # Thread-safe storage for current organization context
  # This ensures tenant isolation across concurrent requests
  def self.current_<%= @organization_name.underscore %>_id
    if defined?(RequestStore)
      RequestStore.store[:current_<%= @organization_name.underscore %>_id] ||
        Thread.current[:current_<%= @organization_name.underscore %>_id]
    else
      Thread.current[:current_<%= @organization_name.underscore %>_id]
    end
  end

  def self.current_<%= @organization_name.underscore %>_id=(id)
    RequestStore.store[:current_<%= @organization_name.underscore %>_id] = id if defined?(RequestStore)
    Thread.current[:current_<%= @organization_name.underscore %>_id] = id
  end

  # Check if tenant scoping context is properly configured
  def self.context_storage_available?
    defined?(RequestStore) || Thread.current.respond_to?(:[])
  end

  # Clear all organization context (use with extreme caution)
  def self.clear_context!
    if Rails.env.production?
      Rails.logger.warn("WARNING: Clearing tenant context in production. Caller: #{caller(1..3)}")
    end

    RequestStore.store[:current_<%= @organization_name.underscore %>_id] = nil if defined?(RequestStore)
    Thread.current[:current_<%= @organization_name.underscore %>_id] = nil
    @current_<%= @organization_name.underscore %> = nil
  end

  def self.current_<%= @organization_name.underscore %>
    return nil unless current_<%= @organization_name.underscore %>_id

    @current_<%= @organization_name.underscore %> ||= <%= @organization_name %>.unscoped.find(current_<%= @organization_name.underscore %>_id)
  end

  def self.current_<%= @organization_name.underscore %>=(<%= @organization_name.underscore %>)
    self.current_<%= @organization_name.underscore %>_id = <%= @organization_name.underscore %>&.id
    @current_<%= @organization_name.underscore %> = <%= @organization_name.underscore %>
  end

  # Set organization context for the duration of a block
  def self.with_<%= @organization_name.underscore %>(<%= @organization_name.underscore %>)
    previous_<%= @organization_name.underscore %>_id = current_<%= @organization_name.underscore %>_id
    previous_<%= @organization_name.underscore %> = @current_<%= @organization_name.underscore %>

    self.current_<%= @organization_name.underscore %> = <%= @organization_name.underscore %>

    yield
  ensure
    self.current_<%= @organization_name.underscore %>_id = previous_<%= @organization_name.underscore %>_id
    @current_<%= @organization_name.underscore %> = previous_<%= @organization_name.underscore %>
  end

  # Clear organization context (use with caution)
  def self.without_<%= @organization_name.underscore %>
    previous_<%= @organization_name.underscore %>_id = current_<%= @organization_name.underscore %>_id
    previous_<%= @organization_name.underscore %> = @current_<%= @organization_name.underscore %>

    self.current_<%= @organization_name.underscore %>_id = nil
    @current_<%= @organization_name.underscore %> = nil

    yield
  ensure
    self.current_<%= @organization_name.underscore %>_id = previous_<%= @organization_name.underscore %>_id
    @current_<%= @organization_name.underscore %> = previous_<%= @organization_name.underscore %>
  end

  # Instance methods
  def belongs_to_current_<%= @organization_name.underscore %>?
    <%= @organization_name.underscore %>_id == TenantScoped.current_<%= @organization_name.underscore %>_id
  end

  def can_be_accessed_by?(<%= @organization_name.underscore %>)
    self.<%= @organization_name.underscore %>_id == <%= @organization_name.underscore %>.id
  end

  private

  def set_current_<%= @organization_name.underscore %>
    return if <%= @organization_name.underscore %>_id.present?
    return unless TenantScoped.current_<%= @organization_name.underscore %>_id

    self.<%= @organization_name.underscore %>_id = TenantScoped.current_<%= @organization_name.underscore %>_id
  end

  def ensure_<%= @organization_name.underscore %>_not_changed
    return unless <%= @organization_name.underscore %>_id_changed?

    errors.add(:<%= @organization_name.underscore %>_id, "cannot be changed after creation")
    throw :abort
  end

  # Module methods for bypass control and monitoring
  module_function

  # Check if bypass operations are enabled in current environment
  def bypass_enabled?
    BYPASS_ENABLED_ENVIRONMENTS.include?(Rails.env)
  end

  # Global flag to temporarily disable all bypass operations (emergency stop)
  def disable_all_bypasses!
    @bypasses_disabled = true
    Rails.logger.error("[EMERGENCY] All tenant scoping bypasses have been globally disabled")
  end

  def enable_bypasses!
    @bypasses_disabled = false
    Rails.logger.warn("[SECURITY] Tenant scoping bypasses have been re-enabled")
  end

  def bypasses_disabled?
    @bypasses_disabled || false
  end

  # Audit trail helpers
  def log_bypass_operation(model_name, operation_type, details = {})
    log_data = {
      model: model_name,
      operation: operation_type,
      timestamp: Time.current,
      environment: Rails.env,
      caller: caller(2..4),
      **details
    }

    Rails.logger.public_send(BYPASS_AUDIT_LOG_LEVEL, "[TENANT_AUDIT] #{log_data.to_json}")
  end
end

# ApplicationController helper methods for setting organization context
# Include this in your ApplicationController or a parent controller
#
# NOTE: For optimal thread safety in production, add the 'request_store' gem to your Gemfile:
#   gem 'request_store'
# The concern will work without it using Thread.current, but RequestStore provides
# better request isolation in multi-threaded environments.
module TenantScoped::ControllerHelpers
  extend ActiveSupport::Concern

  included do
    # Automatically set organization context from current user
    before_action :set_current_<%= @organization_name.underscore %>

    # Helper method available in views
    helper_method :current_<%= @organization_name.underscore %>

    private

    def set_current_<%= @organization_name.underscore %>
      return unless user_signed_in? # Adjust based on your authentication method
      return unless respond_to?(:current_user) && current_user

      # Clear any previous context to prevent cross-request contamination
      TenantScoped.current_<%= @organization_name.underscore %>_id = nil

      # If user has only one organization, use it automatically
      user_<%= @organization_name.underscore.pluralize %> = current_user.<%= @organization_name.underscore.pluralize %>

      if user_<%= @organization_name.underscore.pluralize %>.count == 1
        TenantScoped.current_<%= @organization_name.underscore %> = user_<%= @organization_name.underscore.pluralize %>.first
      elsif params[:<%= @organization_name.underscore %>_id].present?
        # Use organization from params if provided and user has access
        <%= @organization_name.underscore %> = user_<%= @organization_name.underscore.pluralize %>.find_by(id: params[:<%= @organization_name.underscore %>_id])
        if <%= @organization_name.underscore %>
          TenantScoped.current_<%= @organization_name.underscore %> = <%= @organization_name.underscore %>
        else
          Rails.logger.warn("User #{current_user.id} attempted to access unauthorized organization #{params[:<%= @organization_name.underscore %>_id]}")
        end
      elsif session[:current_<%= @organization_name.underscore %>_id].present?
        # Use organization from session if user has access
        <%= @organization_name.underscore %> = user_<%= @organization_name.underscore.pluralize %>.find_by(id: session[:current_<%= @organization_name.underscore %>_id])
        TenantScoped.current_<%= @organization_name.underscore %> = <%= @organization_name.underscore %> if <%= @organization_name.underscore %>
      end

      # Store in session for future requests
      session[:current_<%= @organization_name.underscore %>_id] = TenantScoped.current_<%= @organization_name.underscore %>_id

      # Log context switches for debugging
      if Rails.env.development? && TenantScoped.current_<%= @organization_name.underscore %>_id
        Rails.logger.debug("Set tenant context to organization #{TenantScoped.current_<%= @organization_name.underscore %>_id}")
      end
    rescue => e
      Rails.logger.error("Failed to set organization context: #{e.message}")
      # Clear context on error to prevent data leakage
      TenantScoped.current_<%= @organization_name.underscore %>_id = nil
      raise if Rails.env.development?
    end

    def current_<%= @organization_name.underscore %>
      TenantScoped.current_<%= @organization_name.underscore %>
    end

    def require_<%= @organization_name.underscore %>
      unless TenantScoped.current_<%= @organization_name.underscore %>
        redirect_to <%= @organization_name.underscore.pluralize %>_path, alert: "Please select an <%= @organization_name.underscore %> to continue."
      end
    end

    # Switch organization context (useful for organization selection)
    def switch_<%= @organization_name.underscore %>(<%= @organization_name.underscore %>)
      return unless current_user.<%= @organization_name.underscore.pluralize %>.include?(<%= @organization_name.underscore %>)

      TenantScoped.current_<%= @organization_name.underscore %> = <%= @organization_name.underscore %>
      session[:current_<%= @organization_name.underscore %>_id] = <%= @organization_name.underscore %>.id
    end
  end
end
